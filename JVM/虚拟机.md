# 虚拟机

### 名词：

字面量：int a = 1; String s = "s"; 这种都是字面量。等号右边直接写了个值的这种表示方法就叫字面量表示法，几乎所有语言都支持对基本类型的字面量表示，一些语言也支持字符串，数组，枚举等。

符号引用：描述某个值的地址的信息，但是不是地址本身。可以是个字符串只要能被正确解析成直接引用就行。符号引用的目标可能还没被加载到内存中。可以是1.类和方法的全限定名 2.字段的名称和描述符 3.方法的名称和描述符。

直接引用：引用的存储位置，是具体的地址。指针，句柄都是直接引用。

标量/聚合量：标量即不可被进一步分解的量，而JAVA的基本数据类型就是标量，标量的对立就是可以被进一步分解的量，而这种量称之为聚合量。而在JAVA中对象就是可以被进一步分解的聚合量。

[标量替换/逃逸分析/栈上分配](https://blog.csdn.net/lhl1124281072/article/details/80535611) 

句柄：看书的时候里面提到了句柄，注意和Windows中的句柄不是一个概念。第一款虚拟机在查找对象的时候有一个缺陷：如果堆中有一个字节此时的值是85965，虚拟机搞不明白这表示了一个数值还是一个引用值，所以加了句柄池维护相关信息。句柄指向的就是引用，否则是数值。句柄访问对象的时候需要两次而指针只需要一次，所以HotSpot使用指针。那么后来是通过什么机制，知道指针访问的数据是对象还是基本数据的呢？句柄访问比指针访问多了一次，优点是在GC之后对象位置改变了，栈中的所有指针都要变，如果使用句柄池只需要修改句柄池中的一个值就行了。类似ip访问和域名访问。

动态链接：Class文件中存在大量的符号引用，它们转化为直接引用的时机有两个，一个是加载类的时候会静态解析一部分。还有就是在每一次方法调用的时候动态解析，又叫动态链接。

JavaInJava:这个项目想用Java语言开发出一款虚拟机，让Java在java中运行。但是需要宿主虚拟机，所以搞不明白这项目到底是在干嘛。

函数式编程天然的支持并行：指的是函数式编程的无状态特性。

虚拟机集群部署是什么意思？

GC Roots 的有虚拟机栈中本地变量表中引用的对象、方法区中静态属性引用的对象、方法区中常量引用的对象、本地方法栈中 JNI（Native 方法）引用的对象。

常量池：

Class常量池：

​		Class文件中的某块区域，所有的编译期常量都在里面。每个class文件都有一个class常量池。

运行时常量池：

​		方法区(1.7之前在方法区，1.7以及以后再堆中）的一个区域。运行时常量池也是每个类都有一个。

字符串常量池：

- 在HotSpot VM里实现的string pool功能的是一个StringTable类，它是一个Hash表，默认值大小长度是1009；这个StringTable在每个HotSpot VM的实例只有一份，被所有的类共享。字符串常量由一个一个字符组成，放在了StringTable上。
- 在JDK6.0中，StringTable的长度是固定的，长度就是1009，因此如果放入String Pool中的String非常多，就会造成hash冲突，导致链表过长，当调用String#intern()时会需要到链表上一个一个找，从而导致性能大幅度下降；

- 在JDK7.0中，StringTable的长度可以通过参数指定：-XX:StringTableSize=66666

准确式GC：执行上下文中会单独的维护一份信息，记录着当前上下文中哪个栈槽中有引用，哪个寄存器中有引用。这里不太明白的是：[李晓峰的博客](http://xiao-feng.blogspot.com/)中说，当所有线程暂停时，不一定能够枚举所有的根节点。

保守式GC：保守式GC并不能准备识别每一个无用的对象（比如在32位程序中的一个4字节的值，它是不能判断出它是一个对象指针或者是一个数字的），但是能保证在不会错误的回收存活的对象的情况下回收一部分无用对象。保守式GC不需要额外的数据来支持查找对象的引用，它将所有的内存数据假定为指针，通过一些条件来判定这个指针是否是一个合法的对象。





### 类加载机制：

​		类加载器是 Java 语言的一个创新，也是 Java 语言流行的重要原因之一。它使得 Java 类可以被动态加载到 Java 虚拟机中并执行。类加载器从 JDK 1.0 就出现了，最初是为了满足 Java Applet 的需要而开发出来的。Java Applet 需要从远程下载 Java 类文件到浏览器中并执行。现在类加载器在 Web 容器和 OSGi 中得到了广泛的使用。



​		最终产品：堆区的Class对象

​		基本过程：加载、连接（验证准备解析）、初始化。加载、验证、准备、初始化顺序开始不是顺序结束。解析阶段为了支持动态绑定随时开始。

​			加载：二进制字节流--->方法区的运行时数据结构--->堆中Class对象。

​			连接：验证（安全，正确），准备（分配内存，0值-堆，真实值-常量池）

​			解析：符号-直接引用。

​			初始化：类被使用时触发初始化，初始化父类，初始化语句。

​		类加载器：

​		bootstrap class loader：加载 Java 核心库（JDK\jre\lib)，或被 `-Xbootclasspath`参数指定的路径中的并且能被虚拟机识别的类库。C++编写，开发者无法获取它。

​		extensions class loader：加载Java扩展库（JDK\jre\lib\ext），或者由 `java.ext.dirs`系统变量指定的路径中的所有类库（如javax.开头的类）。开发者可以获取并使用它。

​		app class loader：一般来说Java应用中自己写的类都是它加载的，ClassLoader.getSystemClassLoader();返     回的就是这个类加载器，所以它也被小范围的成为系统类加载器。

​		context class loader：并不是加载器的新品种。它可以为线程设置一个加载器。线程默认继承父线程的上下文加载器。

​		启动类的加载过程是通过调用 `loadClass`来实现的，真正完成类的加载工作是通过调用 `defineClass`来实现的。传说两个实例相同必要条件是被同一个类加载器加载，本质并不是被同一个loadClass加载而是要看defineClass是否相同。加载核心库的加载器无法加载普通Java类。

##### 		Class.forName

- `Class.forName()`：将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块；
- `ClassLoader.loadClass()`：只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。
- `Class.forName(name,initialize,loader)`带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象 。



#### 类加载器与 Web 容器

​        像Tomcat这种web容器，里面可以运行多个web app，但是背后只有一个JVM。这些web app对某些类库使用的版本不一样，这就需要为不同的应用加载不同版本的类库。所以Tomcat中有个自定义的加载器webApplicationClassLoader，每个web应用都会拥有一个此加载器的实例。该类加载器也使用代理模式，所不同的是它是首先尝试去加载某个类，如果找不到再代理给父类加载器。这与一般类加载器的顺序是相反的。这是 Java Servlet 规范中的推荐做法，其目的是使得 Web 应用自己的类的优先级高于 Web 容器提供的类。这种代理模式的一个例外是：Java 核心库的类是不在查找范围之内的。这也是为了保证 Java 核心库的类型安全。



#### 类加载器与 OSGi

​        //这个太难了后面再补充吧

相关阅读

[微信](https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&mid=2247483934&idx=1&sn=41c46eceb2add54b7cde9eeb01412a90&chksm=ebf6da61dc81537721d36aadb5d20613b0449762842f9128753e716ce5fefe2b659d8654c4e8&scene=21#wechat_redirect)  [IBM](https://www.ibm.com/developerworks/cn/java/j-lo-classloader/index.html)  



### 内存区域



引用计数器:

虚拟机栈/本地方法栈:局部变量表，操作数栈（编译期确定大小）。

堆：

方法区/metaspace：类信息，常量池



### 垃圾回收

回收的目标是已经没有用的对象，目前大部分处理的思路并不是去找没有用的对象，而是找到所有有用的对象，然后回收掉所有剩余的对象（精确式GC）。判断一个对象有没有用的算法目前使用的是可达性分析。需要找到GC Roots，它的定义简单说就是当前的执行上下文引用的对象就是有用的。

- 虚拟机栈中引用的对象。
- 方法区中类静态属性实体引用的对象。
- 方法区中常量引用的对象。
- 本地方法栈中JNI引用的对象

GC过程正确执行的必要条件是，回收掉的对象都是真正无用的对象。而依据目前的思路（找到有用的回收掉剩余所有的），保证GC正确执行就需要让GC ROOT在GC过程中没有变动，最低效的做法就是暂停其他所有工作线程，直到GC执行完成。为了让GC更优雅，GC过程引入了一些优化。

##### Safe Point

​		可以安全的进行GC，意思是**收集器在此刻精确的知道，哪些对象是垃圾，哪些不是。至少应该知道，哪些对象是垃圾**。为什么不安全？根据李晓峰的博客，实际上程序并不能通过遍历等方式知道当前执行上下文中所有的GC ROOT。可以选择保守式GC，每次回收一部分可以通过一些手段实锤的无用对象。显然这种方式低效，所以现在用的都是精确式GC。

​		 为了支持精确式GC，JIT编译器需要做一些工作，因为只有JIT是精确的知道栈信息和寄存器中的内容（编译器能否知道栈信息，取决于语言本身。只有安全的语言才有这个能力，C/C++就不行）。当JIT编译一个方法时，对于每条指令，它都可以保存根引用信息，以防该指令暂停执行。但是记录所有指令的信息代价太大了，其实也没必要这样做，因为在真正执行过程中，只有很少一部分指令会遇到GC。因为指令执行的是非常快的，JIT只需要记录其中很少一部分，这些真正被记录的指令信息就被称为安全点。在安全点，垃圾回收器可以知道此时上下文中所有跟节点。也就意味着，在此处执行枚举根节点是安全的。



​		执行GC时，所有的线程都到达安全点才能进行GC。保证所有线程都在安全点的方式：

​		**抢占式中断**：执行GC的时候系统会发送一个中断信号，如果有线程没有处于安全点，会在下一个安全点暂停自己。大多数虚拟机没有使用这种方式。

​		**主动式中断**：当GC想要触发一个集合时，它只需要设置一个标志;线程运行的时候只要运行到polling point就会去查看这个标志，一旦发现设置了标志，就知道马上要GC了。会在下一个safepoint挂起（后面可以知道其实轮询标志的这个点，一定是safe point），并通知GC程序自己已经就绪了。JIT的职责是在适当的位置插入轮询点。编译过程中会直接加入相关指令。

​		**Polling point** ：那么，轮询GC触发器事件的正确位置在哪里呢?轮询点应该足够频繁，以便GC不会等待太长时间等待一个mutator挂起，但又不能太频繁否则会影响工作线程正常执行。

##### safe-region：

​		如果只有safe point是不够高效的。当线程处于sleep或者被系统调用注阻塞的时候，GC等待的时间就会很长。此时就需要safe-region了。safe region是一个单元块，其中的指令不会改变引用，只要进入了这个区域，进行GC就是安全的。

​		safe-region和safe-point的工作过程稍有不同不过原理都一样，线程进入safe-region时会设置就绪标志。离开安全区时会检查GC是否结束，如果结束就继续执行否则暂停自己。



垃圾回收算法：标记 -清除，标记-整理，复制，分代收集

##### CMS收集器

###### 		标记过程：

​		最短回收停顿时间，重视服务的响应速度。基于“标记—清除”算法。它有四个重要过程：

- 初始标记：初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，需要“Stop The World”。
- 并发标记：并发标记阶段就是进行GC Roots Tracing的过程。
- 重新标记：重新标记阶段是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短，仍然需要“Stop The World”。
- 并发清除：并发清除阶段会清除对象。 



​		初始标记阶段，标记执行上下文中的GC ROOT，然后Stop The World就结束了，工作线程继续运行，GC线程同时运行顺着刚才标记的GC ROOT标记所有存活的对象，这就是并发标记的GC Roots Tracing。

因为工作线程不断的产生新的垃圾，刚才的GC ROOT可能都变成垃圾了。所以需要重新标记，去修正哪些GC ROOT不再是GC ROOT，哪些是新产生的GC ROOT。这个阶段需要精确知道对象存活情况，所以也需要STW。具体来说重新标记阶段针对的对象包括这些：

- GC ROOT。如果是前两步处理过的GC ROOT，这时候就不需要过多处理，只需要关心期间引用链上对象的变化情况。这部分信息CMS记录在Card Table上。如果是前两步没有处理过的（期间新产生的）则需要立即进行GC ROOT Trace。
- 初始标至重新标记阶段之间晋升到old阶段的对象。这种对象在前两步中都没有涉及，但是对象可能是存活的。这一步CMS不会判断他们是否存活，都不会清除它们。
- young区所有的对象。young区的对象也会引用old区的对象，这一步骤主要是查找出这部分old的对象。考虑到整个young区对象如果太多，会很耗时。所以有个参数-XX:+CMSScavengeBeforeRemark，每一次使用CMS时都会先进行young GC。
- card table。这一机制下，把老年代划分为一个个512B的区域成为卡片。然后有一个单字节数组，每一个元素对应一张卡片。当卡片中的对象在并发标记阶段修改了引用，就会记录一个标记在卡表对应的位置上，被标记的卡片就变成dirty card。卡表的作用具体参考[美团](https://tech.meituan.com/2017/12/29/jvm-optimize.html) 。理解为什么卡表会在此阶段被考虑，需要了解CMS的三色标记法。



###### 		三色标记法：

​		在GC过程中扫描对象时会对对象进行染色。

​		白色：会被清除的对象，没有被搜索到的对象都是白色。

​		黑色：不会被清除的对象，扫描完成的对象都是黑色。并发标记和并发清除阶段新产生的对象都是黑色。这条规则保证了并发清除阶段不会误杀对象。

​		灰色：正在扫描的对象。是一种短暂的中间状态，一个灰色对象的所有直接引用的对象都被扫描到的时候灰色就会变成黑色。GC ROOT刚开始也是灰色的。

​		整个标记过程结束之后，在并发清除阶段就会清除所有白色的对象。但是由于在并发标记阶段由于引用关系会发生变动，这一机制存在一个漏洞：

​	![1564220821109](C:\Users\hy\AppData\Roaming\Typora\typora-user-images\1564220821109.png)



​	第一步：标记A-灰色，查找A的所有直接引用并标记，B-灰色。A的所有直接引用都被标记为灰色之后，A会变为黑色。此时如左边这张图。恰巧此时对象的引用关系由于程序执行发生变化，变成最右边这张图。那么由于A已经被标记为黑色了，就不会再去重复顺着A再次查找引用关系，所以C就会被漏标记，会在接下来的回收阶段被清除掉。这个漏洞被称为漏标。

​	然而却是需要一个理由重新确认一下A的引用链，这一机制就是利用卡表。当A的引用关系发生改变时，A所处的卡片变为dirty card。remark阶段就会去重新确认这部分对象的引用链。这也就是为什么remark阶段需要扫描卡表的原因。



###### CMS的优缺点：

​	优点：上述过程确实对GC过程进行了一定的优化，让很多操作可以并行。所以对外宣称“永不停顿”。

​	缺点：标记清除会产生很多碎片空间，如果没有足够多的连续内存分配新的对象，就不能用上述过程GC了，需要使用Serial Old对老年代进行GC甚至是触发Full GC。这些情况的停顿时间是非常长的。除此之外还会引发一下问题：



CPU性能问题：

​		这些并行操作虽说减少的停顿时间，但是很明显这一系列复杂的过程无疑增加了计算量。对于CPU压力本身比较大的应用无疑会造成额外的负担。



有些垃圾无法被立即清除：

​		并发清除阶段，死掉的黑色对象被称作浮动对象，这部分垃圾要等到下一次CMS GC时才会被清除。

 

concurrent mode failure：

​		由于在垃圾收集阶段用户线程还需要运行，那也就还需要预留有足够的内存空间给用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。

​		这个异常发生在cms正在回收的时候。执行CMS GC的过程中，同时业务线程也在运行，当年轻带空间满了，执行ygc时，需要将存活的对象放入到老年代，而此时老年代空间不足，这时CMS还没有机会回收老年带产生的，或者在做Minor GC的时候，新生代救助空间放不下，需要放入老年代，而老年代也放不下而产生的。 此时需要Full GC，STW。可以通过设置老年代触发回收的时机去减少这种情况。



promotion failed：

​		在进行Minor GC时，Survivor Space放不下，对象只能放入老年代，而此时老年代也放不下造成的，多数是由于老年带有足够的空闲空间，但是由于碎片较多，新生代要转移到老年带的对象比较大,找不到一段连续区域存放这个对象导致的。      



过早提升与提升失败：

​		在 Minor GC 过程中，Survivor Unused 可能不足以容纳 Eden 和另一个 Survivor 中的存活对象， 那么多余的将被移到老年代， 称为过早提升（Premature Promotion）,这会导致老年代中短期存活对象的增长， 可能会引发严重的性能问题。 再进一步，如果老年代满了， Minor GC 后会进行 Full GC， 这将导致遍历整个堆， 称为提升失败（Promotion Failure）。 



相关阅读：[掘金](https://segmentfault.com/a/1190000005036183) 



##### G1：

​		Java7 update 4之后引入，标记-复制	可控的停顿时间。G1将内存划分一个个固定大小的region，每个region可以是年轻代、老年代的一个。内存的回收是以region作为基本单位的。

###### Heap Region

​		G1垃圾回收器把堆划分成大小相同的Region。每个Region的大小在1-32MB之间，具体多大取决于堆的大小。每个Region要么是young,old,Humongous三种类型之一。对象的大小超过了某一个阈值——HotSpot中是Region的1/2，那么它会被标记为Humongous。

​		每个Region内，有一个指针，指针的一边是已使用的，另一边是未使用的。显然分配内存采用的是指针碰撞法。多线程依然会发生并发问题，解决方案依然是为每个线程分配一个buffer，分配buffer时依然会有并发问题，解决方案是CAS。这种分配buffer的方案会存在碎片空间，

​		由于G1把heap划分为很多个region，一个问题被凸显出来：由CG ROOT寻找所有存活对象变得困难。因为跨多个Region的概率变得很大带来严重的性能开销。G1使用Remembered Set解决这个问题。

###### Remembered Set

​		每个Region中都有一个RS。如果一个对象引用的另一个对象和自己不在同一个Region，会在被引用对象所处的Region记录一份信息。枚举根节点时，把RS也看做根节点，就可以避免扫描多个Region。如果引用关系被修改，会记录一条Remembered Set Logs，等G1进入重新标记阶段，会合并这些Logs然后确定哪些对象存活。



G1的GC过程和CMS很像：

- 初始标记：和CMS一样
- 并发标记：和CMS一样
- 最终标记：目标一样，但是由于结构不同这个步骤需要做的过程不同。
- 筛选回收：G1会对Region进行回收性价比评估，尽可能的保证在用户期望的停顿时间内回收更多的内存。整体看，采用的是标记整理，局部看，采用的是复制算法。

CMS和G1都是是并行收集器，



G1回收器从2004年发表论文，到真正发布商用版本，经历了十年。由此可见G1的复杂性，此处只是对其中某些特性进行了粗略的描述。



